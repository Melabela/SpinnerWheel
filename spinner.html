<html>
<head>
<script type="text/javascript">
  // SIZE CONSTANTS
  const CANVAS_WIDTH = 300;  // height same; assume using square box
  const WHEEL_RADIUS = 100;  // diameter = 200

  // assuming 60 FPS - one full rotation every 2 seconds
  //  Note:  seems like +'ve radians are clockwise, prob. b/c +y is Down
  const ROTATION_PER_FRAME = -(Math.PI / 60);

  // COLOR PALETTES
  // Wedge BG, lighter colors
  // https://coolors.co/palette/fbf8cc-fde4cf-ffcfd2-f1c0e8-cfbaf0-a3c4f3-90dbf4-8eecf5-98f5e1-b9fbc0
  const WEDGE_BG_COLORS = [
    '#F1C0E8',  // pink-red
    '#FFCFD2',  // red
    '#FDE4CF',  // orange
    '#FBF8CC',  // yellow
    '#B9FBC0',  // light-green
    '#98F5E1',  // pink-red
    '#8EECF5',  // light-blue (cyan)
    '#90DBF4',  // med-blue
    '#A3C4F3',  // dark-blue
    '#CFBAF0'   // purple
  ];

  const WEDGE_NUM_TEXT_COLOR = '#707070';
  const WEDGE_NUM_TEXT_FONT = '16px serif';

  const POINTER_COLOR = 'red';

  // globals
  let gb_wheel_spinning;
  let g_rot_offset;

  // FYI - instead of manually calculating rotations,
  //  use Canvas Transformations as shown in MDN 'Clock' example:
  //
  //  https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations#an_animated_clock
  //
  // Idea - leverage Canvas Transforms to do "harder" angle manipulations:
  //  1. draw horiz line (rad=0) and arc portion
  //  2. **rotate canvas by angle**
  //  3. repeat 1. & 2., for next wedge

  function calcPointOnCircle(radius, angleRad) {
    // Note: increasing y is DOWN, in 2D UI co-ordinate system
    //
    // (0,0)  x
    //     .---.
    //      \  |
    //     r \ | y
    //        \|
    //         . (x, y)

    const x = Math.cos(angleRad) * radius;
    const y = Math.sin(angleRad) * radius;
    return [x, y];
  }

  function drawWheelWedge(ctx, idx, radius, rdWedgeAngle) {
    ctx.save();

    // Repeat:
    // - Draw wedge, w/ one edge on horizontal y=0
    // - Rotate entire context, setup for next wedge
    //
    // (0,0)   r
    //  .----------. (x1,y1) = (r,0)
    //    \       /
    //      \    /
    //        \ /
    //         . (x2,y2)

    const [x1, y1] = [radius, 0];
    const [x2, y2] = calcPointOnCircle(radius, rdWedgeAngle);
    // console.log("pt1=(%f, %f)", x1, y1);
    // console.log("pt2=(%f, %f)", x2, y2);

    ctx.beginPath();
    ctx.lineTo(0, 0, x1, y1);
    ctx.arc(0, 0, radius, 0, rdWedgeAngle);
    ctx.lineTo(x2, y2, 0, 0);

    const fillColorIdx = (idx % WEDGE_BG_COLORS.length);
    ctx.fillStyle = WEDGE_BG_COLORS[fillColorIdx];
    // console.log("fillColorIdx=%d, fillColor=%s", fillColorIdx, ctx.fillStyle);
    ctx.fill();

    // if not spinning, also print wedge number
    if (!gb_wheel_spinning) {
      const segNum = idx + 1;
      const xText = (segNum >= 10) ? x1 * 0.6 : x1 * 0.7;
      const yText = y2 / 2;

      ctx.font = WEDGE_NUM_TEXT_FONT;
      ctx.fillStyle = WEDGE_NUM_TEXT_COLOR;
      ctx.fillText(segNum, xText, yText);
    }

    ctx.restore();
  }

  function drawWheelPointer(ctx, canv_width, radius) {
    ctx.save();

    const xWheelTop = canv_width / 2;
    const yWheelTop = (canv_width / 2) - radius;

    // move origin to top of wheel, at "12-oClock" position
    ctx.translate(xWheelTop, yWheelTop);

    const yTriglBtm = 15;
    const yTriglTop = -15;  // most of it sits above wheel
    const xTriglHalfWidth = 8;

    // draw 'pointer' = down-pointing triangle
    ctx.beginPath();
    ctx.lineTo(0, yTriglBtm, xTriglHalfWidth, yTriglTop);
    ctx.lineTo(xTriglHalfWidth, yTriglTop, -xTriglHalfWidth, yTriglTop);
    ctx.lineTo(-xTriglHalfWidth, yTriglTop, 0, yTriglBtm);

    ctx.fillStyle = POINTER_COLOR;
    ctx.fill();

    ctx.restore();
  }

  function drawWheel(ctx, numDivisions, canv_width, radius, rot_offset=0.0) {
    ctx.save();
    ctx.clearRect(0, 0, canv_width, canv_width);

    // move origin to middle of canvas & center of circle,
    //  makes circular operations easier
    ctx.save();

    const midPt = canv_width / 2;
    ctx.translate(midPt, midPt);

    // apply spin offset before we start drawing this frame
    ctx.rotate(rot_offset);

    // for now, have equal-sized wedges
    const rdWedgeAngle = Math.PI * 2 / numDivisions;
    // console.log("rot_offset=%f, rdWedgeAngle=%f", rot_offset, rdWedgeAngle);

    for (idx=0; idx<numDivisions; idx++) {
      drawWheelWedge(ctx, idx, radius, rdWedgeAngle);

      // rotate canvas to do next wedge!
      ctx.rotate(rdWedgeAngle);
    }

    // return to normal canvas; origin = top-left corner, etc.
    ctx.restore();

    drawWheelPointer(ctx, canv_width, radius);

    ctx.restore();
  }

  function draw() {
    const canvas = document.getElementById('spinner');
    if (canvas.getContext) {
      const ctx = canvas.getContext('2d');
      const numDivisions = 10;

      drawWheel(ctx, numDivisions, CANVAS_WIDTH, WHEEL_RADIUS, g_rot_offset);

      // update rotation offset, to make spin
      g_rot_offset += ROTATION_PER_FRAME;
      if (g_rot_offset >= (Math.PI * 2)) {
        g_rot_offset -= (Math.PI * 2);
      }
      if (g_rot_offset < 0.0) {
        g_rot_offset += (Math.PI * 2);
      }

      if (gb_wheel_spinning) {
        window.requestAnimationFrame(draw);
      }
    }
  }

  function init() {
    gb_wheel_spinning = false;
    g_rot_offset = -(Math.PI / 2);  // start w/ 90 deg, make '1' at top

    draw();  // call once to show wheel
  }

  // invert flag, and update button text
  function btnOnClick_Spin() {
    gb_wheel_spinning = !gb_wheel_spinning;

    const btn_spin = document.getElementById('btn_spin');
    btn_spin.innerHTML = (gb_wheel_spinning) ? 'Stop...' : 'Spin!';

    if (gb_wheel_spinning) {
      window.requestAnimationFrame(draw);
    }
  }
</script>
</head>

<body onload="init();">

<h1>Spinner</h1>

<p>
<canvas id="spinner" width=300 height=300></canvas>
</p>

<p>
<button type="button" id="btn_spin" onclick="btnOnClick_Spin();">Spin!</button>
</p>

</body>
</html>

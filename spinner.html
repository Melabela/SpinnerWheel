<html>
<head>
<style type="text/css" media="all">
    #btn_spin {
        margin-left: 80px;
        font-size: 16px;
    }
    p {
        margin-top: 8px;
        margin-bottom: 8px;
    }
    .align_center {
        text-align: center;
    }
</style>
<script type="text/javascript">
  // SIZE CONSTANTS
  const CANVAS_WIDTH = 220;  // height same; assume using square box
  const WHEEL_RADIUS = 100;  // diameter = 200

  // assuming 60 FPS - one full rotation every 2 seconds
  //  Note:  seems like +'ve radians are clockwise, prob. b/c +y is Down
  const ROTATION_PER_FRAME = -(Math.PI / 60);

  // max number of wedges
  const MAX_WEDGES = 10;

  // COLOR PALETTES
  // Wedge BG, lighter colors
  // https://coolors.co/palette/fbf8cc-fde4cf-ffcfd2-f1c0e8-cfbaf0-a3c4f3-90dbf4-8eecf5-98f5e1-b9fbc0
  const WEDGE_BG_COLORS = [
    '#000000',  // [ 0] placeholder, NOT USED
    '#F1C0E8',  // [ 1] pink-red
    '#FFCFD2',  // [ 2] red
    '#FDE4CF',  // [ 3] orange
    '#FBF8CC',  // [ 4] yellow
    '#B9FBC0',  // [ 5] light-green
    '#98F5E1',  // [ 6] pink-red
    '#8EECF5',  // [ 7] light-blue (cyan)
    '#90DBF4',  // [ 8] med-blue
    '#A3C4F3',  // [ 9] dark-blue
    '#CFBAF0'   // [10] purple
  ];

  const WEDGE_NUM_TEXT_COLOR = '#707070';
  const WEDGE_NUM_TEXT_FONT = '16px serif';

  const POINTER_COLOR = 'red';

  // globals
  let gb_wheel_spinning;
  let g_rot_offset;
  let g_wedge_settings;

  // FYI - instead of manually calculating rotations,
  //  use Canvas Transformations as shown in MDN 'Clock' example:
  //
  //  https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Basic_animations#an_animated_clock
  //
  // Idea - leverage Canvas Transforms to do "harder" angle manipulations:
  //  1. draw horiz line (rad=0) and arc portion
  //  2. **rotate canvas by angle**
  //  3. repeat 1. & 2., for next wedge

  function calcPointOnCircle(radius, angleRad) {
    // Note: increasing y is DOWN, in 2D UI co-ordinate system
    //
    // (0,0)  x
    //     .---.
    //      \  |
    //     r \ | y
    //        \|
    //         . (x, y)

    const x = Math.cos(angleRad) * radius;
    const y = Math.sin(angleRad) * radius;
    return [x, y];
  }

  function drawWheelWedge(ctx, idx, radius, rdWedgeAngle) {
    ctx.save();

    // Repeat:
    // - Draw wedge, w/ one edge on horizontal y=0
    // - Rotate entire context, setup for next wedge
    //
    // (0,0)   r
    //  .----------. (x1,y1) = (r,0)
    //    \       /
    //      \    /
    //        \ /
    //         . (x2,y2)

    const [x1, y1] = [radius, 0];
    const [x2, y2] = calcPointOnCircle(radius, rdWedgeAngle);
    // console.log("pt1=(%f, %f)", x1, y1);
    // console.log("pt2=(%f, %f)", x2, y2);

    ctx.beginPath();
    ctx.lineTo(0, 0, x1, y1);
    ctx.arc(0, 0, radius, 0, rdWedgeAngle);
    ctx.lineTo(x2, y2, 0, 0);

    const fillColorIdx = (idx % WEDGE_BG_COLORS.length);
    ctx.fillStyle = WEDGE_BG_COLORS[fillColorIdx];
    // console.log("fillColorIdx=%d, fillColor=%s", fillColorIdx, ctx.fillStyle);
    ctx.fill();

    // if not spinning, also print wedge number
    if (!gb_wheel_spinning) {
      const segNum = idx;
      const xText = (segNum >= 10) ? x1 * 0.6 : x1 * 0.7;
      const yText = y2 / 2;

      ctx.font = WEDGE_NUM_TEXT_FONT;
      ctx.fillStyle = WEDGE_NUM_TEXT_COLOR;
      ctx.fillText(segNum, xText, yText);
    }

    ctx.restore();
  }

  function drawWheelPointer(ctx, canv_width, radius) {
    ctx.save();

    const xWheelTop = canv_width / 2;
    const yWheelTop = (canv_width / 2) - radius;

    // move origin to top of wheel, at "12-oClock" position
    ctx.translate(xWheelTop, yWheelTop);

    const yTriglBtm = 15;
    const yTriglTop = -15;  // most of it sits above wheel
    const xTriglHalfWidth = 8;

    // draw 'pointer' = down-pointing triangle
    ctx.beginPath();
    ctx.lineTo(0, yTriglBtm, xTriglHalfWidth, yTriglTop);
    ctx.lineTo(xTriglHalfWidth, yTriglTop, -xTriglHalfWidth, yTriglTop);
    ctx.lineTo(-xTriglHalfWidth, yTriglTop, 0, yTriglBtm);

    ctx.fillStyle = POINTER_COLOR;
    ctx.fill();

    ctx.restore();
  }

  function drawWheel(ctx, canv_width, radius, rot_offset=0.0) {
    ctx.save();
    ctx.clearRect(0, 0, canv_width, canv_width);

    // move origin to middle of canvas & center of circle,
    //  makes circular operations easier
    ctx.save();

    const midPt = canv_width / 2;
    ctx.translate(midPt, midPt);

    // apply spin offset before we start drawing this frame
    ctx.rotate(rot_offset);

    // console.log("rot_offset=%f", rot_offset);

    for (let idx=1; idx<=MAX_WEDGES; idx++) {
      const wedgeSettings = g_wedge_settings[idx];
      // console.log(`idx=${idx}, wedgeSettings=${JSON.stringify(wedgeSettings)}`);

      if (wedgeSettings.isOn) {
        const rdWedgeAngle = wedgeSettings.angleInRads;
        drawWheelWedge(ctx, idx, radius, rdWedgeAngle);

        // rotate canvas to do next wedge!
        ctx.rotate(rdWedgeAngle);
      }
    }

    // return to normal canvas; origin = top-left corner, etc.
    ctx.restore();

    drawWheelPointer(ctx, canv_width, radius);

    ctx.restore();
  }

  function draw() {
    const canvas = document.getElementById('spinner');
    if (canvas.getContext) {
      const ctx = canvas.getContext('2d');

      drawWheel(ctx, CANVAS_WIDTH, WHEEL_RADIUS, g_rot_offset);

      if (gb_wheel_spinning) {
        // update rotation offset, to make spin
        g_rot_offset += ROTATION_PER_FRAME;
        if (g_rot_offset >= (Math.PI * 2)) {
          g_rot_offset -= (Math.PI * 2);
        }
        if (g_rot_offset < 0.0) {
          g_rot_offset += (Math.PI * 2);
        }

        window.requestAnimationFrame(draw);
      }
    }
  }

  const SETTINGS_ELEM_ID_PREFIXES = [
    'cb_isOn_',
    'num_weight_'
  ];

  function settings_elems_enable(set_on) {
    for (let i=1; i<=MAX_WEDGES; i++) {
      for (const prefix of SETTINGS_ELEM_ID_PREFIXES) {
        const elem_id = prefix + i;
        const elem = document.getElementById(elem_id);
        if (elem) {
          elem.disabled = !set_on;
        }
      }
    }
  }

  function read_settings() {
    const settings = {};

    // 1st loop, read values from elements
    for (let i=1; i<=MAX_WEDGES; i++) {
      const id_elem_isOn = SETTINGS_ELEM_ID_PREFIXES[0] + i;
      const id_elem_weight = SETTINGS_ELEM_ID_PREFIXES[1] + i;

      let isOn = true;
      const elem_isOn = document.getElementById(id_elem_isOn);
      if (elem_isOn) {
        isOn = elem_isOn.checked;
      }

      let weight = 1;
      const elem_weight = document.getElementById(id_elem_weight);
      if (elem_weight) {
        weight = +elem_weight.value;
      }

      const wedge_params = {
        isOn,
        weight,
      };
      settings[i] = wedge_params;
    }
    console.log('settings: {}', settings);
    g_wedge_settings = settings;
  }

  function compute_wedge_angles() {
    // 1st loop, get sum of (active) weights
    let total_weight = 0;
    for (let i=1; i<=MAX_WEDGES; i++) {
      if (g_wedge_settings[i].isOn) {
        total_weight += g_wedge_settings[i].weight;
      }
    }

    // 2nd loop, compute angles based on relative weights
    for (let i=1; i<=MAX_WEDGES; i++) {
      const settings = g_wedge_settings[i];
      if (settings.isOn) {
        const ratio = (settings.weight / total_weight);
        const angleInRads = ratio * (Math.PI * 2);

        settings.ratio = ratio;
        settings.angleInRads = angleInRads;
      }
      else {
        settings.ratio = 0.0;
        settings.angleInRads = 0.0;
      }
    }
  }

  // encode 'isOn' and 'weight' per wedge into ascii-char
  //  e.g. (1, 3) -> binary(011_<1-bit: isOn>_<4-bit: weight>)
  //        = 011_1_0011 = hex(0x73) = ascii('s')
  function encode_settings(settings) {
    const out_chars = [];
    for (let i=1; i<=MAX_WEDGES; i++) {
      const isOn = settings[i].isOn;
      const weight = settings[i].weight;
      const ascii_val = 0x60 + (isOn ? 0x10 : 0) + (weight & 0xf);
      out_chars.push(String.fromCharCode(ascii_val));
    }
    const out_str = out_chars.join('');
    return out_str;
  }

  // reverse of encode_settings()
  //  e.g. input = "aqqqqavqcq"
  // disassemble as [1] = 'isOn'.'weight' / [2] / [3] / ...
  function decode_settings(str) {
    const out_settings = {};

    for (let i=0; i<MAX_WEDGES; i++) {
      const ascii_val = str.charCodeAt(i);
      const isOn = ((ascii_val & 0x10) != 0);
      const weight = (ascii_val & 0xf);
      out_settings[i+1] = {
        isOn,
        weight
      };
    }

    return out_settings;
  }

  function inputOnChange_Settings() {
    read_settings();
    compute_wedge_angles();

    // -- TESTING --
    const encode_str = encode_settings(g_wedge_settings);
    console.log('encode_str:', encode_str);
    const decode_set = decode_settings(encode_str);
    console.log('decode_settings:', decode_set);
    // -- TESTING --

    draw();
  }

  // invert flag, and update button text
  function btnOnClick_Spin() {
    gb_wheel_spinning = !gb_wheel_spinning;

    const btn_spin = document.getElementById('btn_spin');
    btn_spin.innerHTML = (gb_wheel_spinning) ? 'Stop...' : 'Spin!';

    settings_elems_enable(!gb_wheel_spinning);

    if (gb_wheel_spinning) {
      window.requestAnimationFrame(draw);
    }
  }

  // reset all wedge settings to: (on, weight=1)
  function settings_reset() {
    for (let i=1; i<=MAX_WEDGES; i++) {
      const id_elem_isOn = SETTINGS_ELEM_ID_PREFIXES[0] + i;
      const id_elem_weight = SETTINGS_ELEM_ID_PREFIXES[1] + i;

      const elem_isOn = document.getElementById(id_elem_isOn);
      if (elem_isOn) {
        elem_isOn.checked = true;
      }

      const elem_weight = document.getElementById(id_elem_weight);
      if (elem_weight) {
        elem_weight.value = 1;
      }
    }
  }

  function btnOnClick_Reset() {
    settings_reset();
    read_settings();
    compute_wedge_angles();
    draw();  // call once to update wheel
  }

  function set_wedge_num_cell_bg() {
    const ELEM_PREFIX = 'wedge_num_';
    for (let i=1; i<=MAX_WEDGES; i++) {
      const id_elem = ELEM_PREFIX + i;
      const bg_color = WEDGE_BG_COLORS[i];

      const elem = document.getElementById(id_elem);
      if (elem) {
        elem.style.backgroundColor = bg_color;
      }
    }
  }

  function init() {
    gb_wheel_spinning = false;
    g_rot_offset = -(Math.PI / 2);  // start w/ 90 deg, make '1' at top

    set_wedge_num_cell_bg();
    settings_reset();
    read_settings();
    compute_wedge_angles();
    draw();  // call once to show wheel
  }
</script>
</head>

<body onload="init();">

<h1>Spinner</h1>

<canvas id="spinner" width=220 height=220></canvas>

<p>
<button type="button" id="btn_spin" onclick="btnOnClick_Spin();">Spin!</button>
</p>

<hr />

<h2>Settings</h2>

</p>
<button type="button" id="btn_reset" onclick="btnOnClick_Reset();">Reset</button>
</p>

<table id="tbl_wedge_settings">
    <tr>
        <th>Wedge #</th>
        <th>On?</th>
        <th>Rel. Weight</th>
    </tr>
    <tr>
        <td class="align_center" id="wedge_num_1">1</td>
        <td><input type="checkbox" checked=true id="cb_isOn_1" onchange="inputOnChange_Settings();" /></td>
        <td><input type="number" value="1" min="1" max="9" id="num_weight_1" onchange="inputOnChange_Settings();" /></td>
    </tr>
    <tr>
        <td class="align_center" id="wedge_num_2">2</td>
        <td><input type="checkbox" checked=true id="cb_isOn_2" onchange="inputOnChange_Settings();" /></td>
        <td><input type="number" value="1" min="1" max="9" id="num_weight_2" onchange="inputOnChange_Settings();" /></td>
    </tr>
    <tr>
        <td class="align_center" id="wedge_num_3">3</td>
        <td><input type="checkbox" checked=true id="cb_isOn_3" onchange="inputOnChange_Settings();" /></td>
        <td><input type="number" value="1" min="1" max="9" id="num_weight_3" onchange="inputOnChange_Settings();" /></td>
    </tr>
    <tr>
        <td class="align_center" id="wedge_num_4">4</td>
        <td><input type="checkbox" checked=true id="cb_isOn_4" onchange="inputOnChange_Settings();" /></td>
        <td><input type="number" value="1" min="1" max="9" id="num_weight_4" onchange="inputOnChange_Settings();" /></td>
    </tr>
    <tr>
        <td class="align_center" id="wedge_num_5">5</td>
        <td><input type="checkbox" checked=true id="cb_isOn_5" onchange="inputOnChange_Settings();" /></td>
        <td><input type="number" value="1" min="1" max="9" id="num_weight_5" onchange="inputOnChange_Settings();" /></td>
    </tr>
    <tr>
        <td class="align_center" id="wedge_num_6">6</td>
        <td><input type="checkbox" checked=true id="cb_isOn_6" onchange="inputOnChange_Settings();" /></td>
        <td><input type="number" value="1" min="1" max="9" id="num_weight_6" onchange="inputOnChange_Settings();" /></td>
    </tr>
    <tr>
        <td class="align_center" id="wedge_num_7">7</td>
        <td><input type="checkbox" checked=true id="cb_isOn_7" onchange="inputOnChange_Settings();" /></td>
        <td><input type="number" value="1" min="1" max="9" id="num_weight_7" onchange="inputOnChange_Settings();" /></td>
    </tr>
    <tr>
        <td class="align_center" id="wedge_num_8">8</td>
        <td><input type="checkbox" checked=true id="cb_isOn_8" onchange="inputOnChange_Settings();" /></td>
        <td><input type="number" value="1" min="1" max="9" id="num_weight_8" onchange="inputOnChange_Settings();" /></td>
    </tr>
    <tr>
        <td class="align_center" id="wedge_num_9">9</td>
        <td><input type="checkbox" checked=true id="cb_isOn_9" onchange="inputOnChange_Settings();" /></td>
        <td><input type="number" value="1" min="1" max="9" id="num_weight_9" onchange="inputOnChange_Settings();" /></td>
    </tr>
    <tr>
        <td class="align_center" id="wedge_num_10">10</td>
        <td><input type="checkbox" checked=true id="cb_isOn_10" onchange="inputOnChange_Settings();" /></td>
        <td><input type="number" value="1" min="1" max="9" id="num_weight_10" onchange="inputOnChange_Settings();" /></td>
    </tr>
</table>


</body>
</html>
